2020-11-27 23:36:35 +0100
find a clear vertical structure seen at speed.
check if this is consistent with the horizontal angle calibration.

Perhaps nice one:
sweep 71 of 2011_09_26/2011_09_26_drive_0002_extract
pretty fast speed car; pole on the right

plot "0000000071.txt" using (atan2($2,$1)):(atan($3/sqrt($1**2+$2**2))):((sqrt($1**2+$2**2+$3**2)>5?1/0:(sqrt($1**2+$2**2+$3**2)<4.5?1/0:sqrt($1**2+$2**2+$3**2)))) with points palette
plot "sweep" using 5:7:(($9>5?1/0:($9<4.5?1/0:$9))) with points palette

make script that adds probe nr to sweep file (or do I have that already...).
awk '{print $0*3.1415927/180}' rot_correcties > rot_correcties_rad

time was 2011-09-26 13:02:51.436725546
forward speed was 12.181075502715 m/s (2011_09_26/2011_09_26_drive_0002_extract/oxts/data/0000000749.txt
= 43.85 km/h
lidar rotation : 10 * 2 * pi * 1000 mrad/s
horizontal offsets are in +/- 160 mrad interval
thus at most 320 mrad
the car drives .2 mm, per mrad rotation of the lidar
thus in 320 mrad the car thus drives 64 mm
pole is at 4.6 m distance
thus angular error is at most 64 / 4600 = 14 mrad
Almost what I see in the data: 5022.43 - 5005.96 = 16.47 (probe 22 - probe 46 (in my not correct upside down counting))
The difference can be explained by the sampling

Now to check if the rot_corrections can explain for the specific probe results
hmmm, what's the order of rot_correcties ?
hmmm, rotation corrections are specified on firing order. The vertical corrections should thus be used to determine the vertical-offset order.

Let me first plot the upper and lower lidar together...
replot "sweep" using 5:($7-32 + .3):(($9>5?1/0:($9<4.5?1/0:$9))) with points palette
no, doesn't give the same pattern, I wonder if the upper and lower are not mirrored, should check the doc.
doc says not mirrored, strange...

implemented computing the order, seems to be consistent with the doc

plot [0:7][64:0] "sweep" using 5:7:(($9>5?1/0:($9<4.5?1/0:$9))) with points palette
plot [0:7][64:0] "sweep" using 5:7:(($9>5?1/0:($9<4.5?1/0:$8))) with labels  # hmmm, this is way too slow...

Let's try to manually check some of the probes
vertically consecutive probes are always left and right
y-id  p-id obs-ang  cor-ang
20    52   5.01486  0.0968532
22    58   5.00772 -0.156948
-> +7.14 mrad difference
.00714 rad * 4600 mm = 32.84400 mm
32.84400 mm / .2 mm/mrad = 164 mrad
probe 58 is 164 mrad pointing to right with respect to probe 52
hmmm, does not fit cor-ang:
0.0968532 -  -0.156948 = .253801
hmmm, horizontal sampling rate is 3 mrad... so up to 6 mrad error when comparing two, up to .006 * 4600 / .2 = .138 rad error. can explain this nonfit
Okay, so... could be and I can use it to deduce the sign of the correction

let's try align based on time... I assume I should then add the rot_correction (+)
... hmm, the stars do not align (not with the minus either btw...)
Sigh... I should have a look at actually reverse engineering the "calibration" script. I'm clearly missing something...
.... or ...or the calibration is not the one actually used for kitti. ...can I reverse engineer somehow??? pffff

Nice visualization of the probe positions according to the calibration file:
plot [][5:-25] "../rot_correcties_both" using 1:2:0 with labels

with + probe 20 has a 4+ at 4.29 and 4.62, probe 19 has similar pattern (at least in between those) with only 3+ shift. Hmmm other probes also seem to have the same pattern shifted by some 10+'s
let's do some hacking to get the alignment based on those patterns
yes pattern is clearly visible, seems to be related to vertical angle
plot [0:7][64:0] "sweep" using 10:7:11 with labels
let's first just remove those angles manually, and later check if it's actually something in the calibration (some crosstalking with vertical angle)
Hmmm, or with the distance of the point course.

But proven now: indeed the jumps are the same for all probes

started to decipher the script to apply the calibration. No way to test it of course....

finished script, seems to be working
found ros implementation: velodyne/velodyne_pointcloud/src/lib/rawdata.cc from https://github.com/ros-drivers/velodyne.git
seems to have made the same choices based on the manual.
reverse engineered calibration.
Now to try it on a kitti scan

should split of the code in a separate repo named:
ITTIK I jusT wanT my kittI bacK -> did that
doesn't work on kitti scan. Will try to do just one point and see what's happening, might be just some x-y conversion. 
should also check what suma is actually doing... it should use the calibration somehow... -> no it's not taking it into account it seems.
there's also some code in https://gist.github.com/pierriko/6bbcb287aaf23358fe0a btw, with some nice asci art 
Aha, found a buggy, was using the wrong probe ids. Now it makes more sense, but not perfect yet. seems indeed x-y conversion because lines start at about pi/2 and going down.
Hmmm, seems the kitty xyz data is rotating anti-clockwise, while the velodyne itself is rotating clockwise. I also wonder what the orientation of the velodyne is on the car... seems a kitti-sweep start at the back of the car, but I do not know if that's also the zero-position of the velodyne. (sigh...)
Rotating by pi/2 doesn't really help: error stays 1 to 10 mrad (though difficult to judge with high error). I wonder if the calibration is actually dependend on the rotation position...
Probe 31 is acting very strange -> and that's probably because it is aimed close to the horizon. The algorithm is just not that stable.
Is the "error" actually the timing difference? -> nope, I already ordered them by probe_id = time.

Let's try to get a more stable method to get the position back, perhaps iterate somehow
Btw, checked the stability. Indeed the mm-accuracy of the lidar points has a big effect on the rotation position for close to horizon points. 
Implemented a hacky iterative method. Seems much better for all probes, but still position dependend position error.
Okay, a +/- error: now the position error is independent. Can still be up to 8 mrad though
the distance error between the point and the reprojected point is quite high: up to 5 cm
fixed that, was a similar +/- bug. Now its mostly under 1cm and under 1mm. Did not change the position error though.
so.... was a different calibration file used?? Or the mm accuracy? Seems not the second, because there's a lot of regularity in the error.

On the angle between two fires of a consecutive lasers:
You would assume a uniform firing for the lasers. 1.3 M /s -> .77 microsec * 2 (because lasers fire in pairs) = 1.54 microsec.
in which the device rotated 2pi*10 /s * 1.54 microsec = 96.8 microrad
But the manual says .73 microsecond between each fire
in which the device rotated 2pi*10 /s * .73 microsec = 45.9 microrad
Clear that there some measurements dropped, as also visible in the measurements themselves

Again: 100000 us / ((401.83 - 285.35) / 5) us = 4292.58 fires per sweep (of which roughly half is measured)

-------------------
On to reverting the motion correction.
Let me check for which of the Odometry datasets the raw data is available
00: 2011_10_03_drive_0027 000000 004540 -> residential
01: 2011_10_03_drive_0042 000000 001100 -> road (highway)
02: 2011_10_03_drive_0034 000000 004660 -> residential
03: 2011_09_26_drive_0067 000000 000800 -> nope
04: 2011_09_30_drive_0016 000000 000270 -> road (only 1.1GB, but very straight) +3
05: 2011_09_30_drive_0018 000000 002760 -> residential
06: 2011_09_30_drive_0020 000000 001100 -> residential
07: 2011_09_30_drive_0027 000000 001100 -> residential
08: 2011_09_30_drive_0028 001100 005170 -> residential
09: 2011_09_30_drive_0033 000000 001590 -> residential
10: 2011_09_30_drive_0034 000000 001200 -> residential

Only for 03 the raw data is missing. These are only the train sets and not the
11 test sets. The Odometry data can only be downloaded as a whole.
Let om try 04...
Seems the offset of the sweeps is off by 3. That is: the first 3 sweeps are missing.
Quite some overlap of projected points in the motion corrected data, let me try to color with the semantic labels:
rgb(r,g,b) = int(r)*65536 + int(g)*256 + int(b)
 plot "<(paste -d' ' tmp/000000_from*)" using (atan2($2,$1)):(atan($3/sqrt($1**2+$2**2))):(rgb($5,$6,$7)) pt 7 lc rgb variable
would be good to project to pixels like done in other works, and count the number of overlapping conflicting labels.

Perhaps I should just not try to undo the egomotion, but just use the raw datasets instead. Let's try to find out the test-set.
Download all raw data.... ~100 GB, 2MB/s -> 50K s = 14h (space for 150 GB on disc) ... turned out to be 244G
odometry data: ll bin / 16 -> nr of points
grrr, some hacky grepping revealed that none of the test-sets, except for 20 (from 2011_10_03_drive_0047), is in the raw sets.

Hmmm, interesting btw: the odometry datasets are stored with higher .1mm accuracy.

Let's now try to revert the motion-correction. First just try not taking it into account and work backwards in time. Plus check that the reference frame is still the same, or that also changed. That last thing can be checked by first using a scan when the car was not moving, which should result in approx the same points.
Motion seems to be referenced at pi/2. But it is not exactly on the mark. Up to 1mrad error. Especially for the upper lasers. Perhaps reference is pitch-roll = 0, which would have a bigger inpact for upper lasers.
Now try to compute poses relative to pi/2 one and readjust points before unapplying the calibration. Perhaps first the pitch/roll.
... And first double check the .bin points of the raw sets. -> yes they are
plot path using:
plot "<(cat ../kitti/2011_09_30/2011_09_30_drive_0016_extract/oxts/data/*)"
scan with no movement: 2011_09_30/2011_09_30_drive_0018_extract/velodyne_points/data/0000002363.txt
-> no movement, approx the same point, so reference frame is the laser at a certain time.
100 ms -> 3m.
Grrr there's strange jumps in the oxts data, such as in 2011_09_30_drive_0018_extract measurement 5663 - 5664. It seems there was some data cut out, but the timestamps do not have this gap. Pffff. I wonder how the lidar measurement looks at that place.... ... hmmm perhaps it is just the imu-filter acting crazy, there are a lot of different strange artifacts.
Let's now try my 3d spline interpolation.... (though I guess simple angle-averaging was used)
He, seems to actually already work quite nicely, even with the rough scan_time approximation. Pattern is visible. Not directly usable thought.
using the estimated heading again for a time estimate makes it even work better.

Moving to pose estimation
should check vertical angle in the raw data -> pretty good, < 2 mrad error; well some are 6 mrad, while the difference between 2 lasers is sometimes also 6 mrad... so just not good enough to estimate probeId...
well... perhaps those are strange outliers anyways.... should check that...
Wow, the rotational position of the different sweeps are very much the same...
Hmmmm.... when I paste sweep 01 after sweep 00 then they do not seem to fit, they have different different timing 
-> that's because how I unapply calibration...
-> no... also the original split does seem to fit. ...let me find the place where it's actually split. Or are sweeps missing... 
Let me get a motion-corrected sweep when the car is rotating, e.g. from odo-set 05: 2011_09_30_drive_0018, scan 794 or 1810
-> the seem is at pi... so that would be where it should "fit" with the next sweep. I should try this with 1810 where it is clear where it starts and stops
what seems to me to be the case is that the scans are split by device-rotation at some perhaps arbitrary orientation, and then saved as "point-clouds" starting from point heading 0. -> Yas, confirmed on 1810 at -pi/2 (because of my atan screwup)
But something is strange. The points where it wraps (at -pi/2) are not on the edges of the motion corrected one.
Is the motion correction not taking the position of the point into account... or are it actually different points (nope, reflectivity is the same)
If not taken into account then there should be errors at the edges of the sweep. ...how to see those...

 plot "odo_05_001810.txt" using (atan2($2,$1)):(atan($3/sqrt($1**2+$2**2)))
 replot "odo_05_001810.txt" using (-3<atan2($2,$1)?(atan2($2,$1)<3?1/0:atan2($2,$1)):atan2($2,$1)):(atan($3/sqrt($1**2+$2**2))):($0) with labels

 plot "raw_05_001813_unap.txt" using 2:1
 replot "raw_05_001813_unap.txt" using ($0==108312?$2:1/0):1:0 with labels lc "blue"
 replot "raw_05_001813_unap.txt" using ($0==106327?$2:1/0):1:0 with labels lc "blue"
 replot "raw_05_001813_unap.txt" using ($0==102337?$2:1/0):1:0 with labels lc "blue"
 replot "raw_05_001813_unap.txt" using ($0==100294?$2:1/0):1:0 with labels lc "blue"
 replot "raw_05_001813_unap.txt" using ($0==98219?$2:1/0):1:0 with labels lc "blue"
 replot "raw_05_001813_unap.txt" using ($0==96153?$2:1/0):1:0 with labels lc "blue"
 replot "raw_05_001813_unap.txt" using ($0==94099?$2:1/0):1:0 with labels lc "blue"

Assuming now that laser positions were not taken into account during motion correction. Especially behind the car this can result in big errors because points measured at the start of the sweep are ended to the end and vice versa.

Fix the rotational position angle, such that it is in line with the horizontal point angle -> fixed
Use the correct begin and end of sweep ; check with consecutive sweep -> fixed (made a script for it)
adjusted unapply_motion_sweep script and works for the straight ahead sweep, though not perfect
try out other sweeps -> a bit more problems when there's rotation
hmmm in 1810 of 2011_09_30_drive_0018 there's a rare occurrence of one of the laser firing an extra time, while the others don't at .1 degrees
compare raw_unap data -> looks okayish but not perfect
read poses, pose-times and velodyne-times from the odometry dataset -> seems poses are in camera frame or something... have to undo those calibrations -> calibrations are given in the odometry dataset (in yet a different form : - ), precisly described in the devkit/readme.txt of the odometry dataset
...discretize
