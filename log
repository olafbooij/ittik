2020-11-27 23:36:35 +0100
find a clear vertical structure seen at speed.
check if this is consistent with the horizontal angle calibration.

Perhaps nice one:
sweep 71 of 2011_09_26/2011_09_26_drive_0002_extract
pretty fast speed car; pole on the right

plot "0000000071.txt" using (atan2($2,$1)):(atan($3/sqrt($1**2+$2**2))):((sqrt($1**2+$2**2+$3**2)>5?1/0:(sqrt($1**2+$2**2+$3**2)<4.5?1/0:sqrt($1**2+$2**2+$3**2)))) with points palette
plot "sweep" using 5:7:(($9>5?1/0:($9<4.5?1/0:$9))) with points palette

make script that adds probe nr to sweep file (or do I have that already...).
awk '{print $0*3.1415927/180}' rot_correcties > rot_correcties_rad

time was 2011-09-26 13:02:51.436725546
forward speed was 12.181075502715 m/s (2011_09_26/2011_09_26_drive_0002_extract/oxts/data/0000000749.txt
= 43.85 km/h
lidar rotation : 10 * 2 * pi * 1000 mrad/s
horizontal offsets are in +/- 160 mrad interval
thus at most 320 mrad
the car drives .2 mm, per mrad rotation of the lidar
thus in 320 mrad the car thus drives 64 mm
pole is at 4.6 m distance
thus angular error is at most 64 / 4600 = 14 mrad
Almost what I see in the data: 5022.43 - 5005.96 = 16.47 (probe 22 - probe 46 (in my not correct upside down counting))
The difference can be explained by the sampling

Now to check if the rot_corrections can explain for the specific probe results
hmmm, what's the order of rot_correcties ?
hmmm, rotation corrections are specified on firing order. The vertical corrections should thus be used to determine the vertical-offset order.

Let me first plot the upper and lower lidar together...
replot "sweep" using 5:($7-32 + .3):(($9>5?1/0:($9<4.5?1/0:$9))) with points palette
no, doesn't give the same pattern, I wonder if the upper and lower are not mirrored, should check the doc.
doc says not mirrored, strange...

implemented computing the order, seems to be consistent with the doc

plot [0:7][64:0] "sweep" using 5:7:(($9>5?1/0:($9<4.5?1/0:$9))) with points palette
plot [0:7][64:0] "sweep" using 5:7:(($9>5?1/0:($9<4.5?1/0:$8))) with labels  # hmmm, this is way too slow...

Let's try to manually check some of the probes
vertically consecutive probes are always left and right
y-id  p-id obs-ang  cor-ang
20    52   5.01486  0.0968532
22    58   5.00772 -0.156948
-> +7.14 mrad difference
.00714 rad * 4600 mm = 32.84400 mm
32.84400 mm / .2 mm/mrad = 164 mrad
probe 58 is 164 mrad pointing to right with respect to probe 52
hmmm, does not fit cor-ang:
0.0968532 -  -0.156948 = .253801
hmmm, horizontal sampling rate is 3 mrad... so up to 6 mrad error when comparing two, up to .006 * 4600 / .2 = .138 rad error. can explain this nonfit
Okay, so... could be and I can use it to deduce the sign of the correction

let's try align based on time... I assume I should then add the rot_correction (+)
... hmm, the stars do not align (not with the minus either btw...)
Sigh... I should have a look at actually reverse engineering the "calibration" script. I'm clearly missing something...
.... or ...or the calibration is not the one actually used for kitti. ...can I reverse engineer somehow??? pffff

Nice visualization of the probe positions according to the calibration file:
plot [][5:-25] "../rot_correcties_both" using 1:2:0 with labels

with + probe 20 has a 4+ at 4.29 and 4.62, probe 19 has similar pattern (at least in between those) with only 3+ shift. Hmmm other probes also seem to have the same pattern shifted by some 10+'s
let's do some hacking to get the alignment based on those patterns
yes pattern is clearly visible, seems to be related to vertical angle
plot [0:7][64:0] "sweep" using 10:7:11 with labels
let's first just remove those angles manually, and later check if it's actually something in the calibration (some crosstalking with vertical angle)
Hmmm, or with the distance of the point course.

But proven now: indeed the jumps are the same for all probes

started to decipher the script to apply the calibration. No way to test it of course....

finished script, seems to be working
found ros implementation: velodyne/velodyne_pointcloud/src/lib/rawdata.cc from https://github.com/ros-drivers/velodyne.git
seems to have made the same choices based on the manual.
reverse engineered calibration.
Now to try it on a kitti scan

should split of the code in a separate repo named:
ITTIK I jusT wanT my kittI bacK -> did that
doesn't work on kitti scan. Will try to do just one point and see what's happening, might be just some x-y conversion.
should also check what suma is actually doing... it should use the calibration somehow... -> no it's not taking it into account it seems.
there's also some code in https://gist.github.com/pierriko/6bbcb287aaf23358fe0a btw, with some nice asci art
Aha, found a buggy, was using the wrong probe ids. Now it makes more sense, but not perfect yet. seems indeed x-y conversion because lines start at about pi/2 and going down.
Hmmm, seems the kitty xyz data is rotating anti-clockwise, while the velodyne itself is rotating clockwise. I also wonder what the orientation of the velodyne is on the car... seems a kitti-sweep start at the back of the car, but I do not know if that's also the zero-position of the velodyne. (sigh...)
Rotating by pi/2 doesn't really help: error stays 1 to 10 mrad (though difficult to judge with high error). I wonder if the calibration is actually dependend on the rotation position...
Probe 31 is acting very strange -> and that's probably because it is aimed close to the horizon. The algorithm is just not that stable.
Is the "error" actually the timing difference? -> nope, I already ordered them by probe_id = time.

Let's try to get a more stable method to get the position back, perhaps iterate somehow
Btw, checked the stability. Indeed the mm-accuracy of the lidar points has a big effect on the rotation position for close to horizon points.
Implemented a hacky iterative method. Seems much better for all probes, but still position dependend position error.
Okay, a +/- error: now the position error is independent. Can still be up to 8 mrad though
the distance error between the point and the reprojected point is quite high: up to 5 cm
fixed that, was a similar +/- bug. Now its mostly under 1cm and under 1mm. Did not change the position error though.
so.... was a different calibration file used?? Or the mm accuracy? Seems not the second, because there's a lot of regularity in the error.

On the angle between two fires of a consecutive lasers:
You would assume a uniform firing for the lasers. 1.3 M /s -> .77 microsec * 2 (because lasers fire in pairs) = 1.54 microsec.
in which the device rotated 2pi*10 /s * 1.54 microsec = 96.8 microrad
But the manual says .73 microsecond between each fire
in which the device rotated 2pi*10 /s * .73 microsec = 45.9 microrad
Clear that there some measurements dropped, as also visible in the measurements themselves

Again: 100000 us / ((401.83 - 285.35) / 5) us = 4292.58 fires per sweep (of which roughly half is measured)
  -> well, actually it is exactly 4000

-------------------
On to reverting the motion correction.
Let me check for which of the Odometry datasets the raw data is available
00: 2011_10_03_drive_0027 000003 004543 -> residential
01: 2011_10_03_drive_0042 000004 001104 -> road (highway)
02: 2011_10_03_drive_0034 000003 004663 -> residential
03: 2011_09_26_drive_0067 00000? 00080? -> nope
04: 2011_09_30_drive_0016 000003 000273 -> road (only 1.1GB, but very straight) +3
05: 2011_09_30_drive_0018 000003 002763 -> residential (bit big, lots of bents) +3
06: 2011_09_30_drive_0020 000003 001103 -> residential
07: 2011_09_30_drive_0027 000004 001104 -> residential
08: 2011_09_30_drive_0028 001103 005173 -> residential
09: 2011_09_30_drive_0033 000003 001593 -> residential
10: 2011_09_30_drive_0034 000003 001203 -> residential

Only for 03 the raw data is missing. These are only the train sets and not the
11 test sets. The Odometry data can only be downloaded as a whole.
Let om try 04...
Seems the offset of the sweeps is off by 3. That is: the first 3 sweeps are missing.
Quite some overlap of projected points in the motion corrected data, let me try to color with the semantic labels:
rgb(r,g,b) = int(r)*65536 + int(g)*256 + int(b)
 plot "<(paste -d' ' tmp/000000_from*)" using (atan2($2,$1)):(atan($3/sqrt($1**2+$2**2))):(rgb($5,$6,$7)) pt 7 lc rgb variable
would be good to project to pixels like done in other works, and count the number of overlapping conflicting labels.

Perhaps I should just not try to undo the egomotion, but just use the raw datasets instead. Let's try to find out the test-set.
Download all raw data.... ~100 GB, 2MB/s -> 50K s = 14h (space for 150 GB on disc) ... turned out to be 244G
odometry data: ll bin / 16 -> nr of points (ls -l *.bin |awk '{print $5/16}')
grrr, some hacky grepping revealed that none of the test-sets, except for 20 (from 2011_10_03_drive_0047), is in the raw sets.

Hmmm, interesting btw: the odometry datasets are stored with higher .1mm accuracy.

Let's now try to revert the motion-correction. First just try not taking it into account and work backwards in time. Plus check that the reference frame is still the same, or that also changed. That last thing can be checked by first using a scan when the car was not moving, which should result in approx the same points.
Motion seems to be referenced at pi/2. But it is not exactly on the mark. Up to 1mrad error. Especially for the upper lasers. Perhaps reference is pitch-roll = 0, which would have a bigger inpact for upper lasers.
Now try to compute poses relative to pi/2 one and readjust points before unapplying the calibration. Perhaps first the pitch/roll.
... And first double check the .bin points of the raw sets. -> yes they are
plot path using:
plot "<(cat ../kitti/2011_09_30/2011_09_30_drive_0016_extract/oxts/data/*)"
scan with no movement: 2011_09_30/2011_09_30_drive_0018_extract/velodyne_points/data/0000002363.txt
-> no movement, approx the same point, so reference frame is the laser at a certain time.
100 ms -> 3m.
Grrr there's strange jumps in the oxts data, such as in 2011_09_30_drive_0018_extract measurement 5663 - 5664. It seems there was some data cut out, but the timestamps do not have this gap. Pffff. I wonder how the lidar measurement looks at that place.... ... hmmm perhaps it is just the imu-filter acting crazy, there are a lot of different strange artifacts.
Let's now try my 3d spline interpolation.... (though I guess simple angle-averaging was used)
He, seems to actually already work quite nicely, even with the rough scan_time approximation. Pattern is visible. Not directly usable thought.
using the estimated heading again for a time estimate makes it even work better.

Moving to pose estimation
should check vertical angle in the raw data -> pretty good, < 2 mrad error; well some are 6 mrad, while the difference between 2 lasers is sometimes also 6 mrad... so just not good enough to estimate probeId...
well... perhaps those are strange outliers anyways.... should check that...
Wow, the rotational position of the different sweeps are very much the same...
Hmmmm.... when I paste sweep 01 after sweep 00 then they do not seem to fit, they have different different timing
-> that's because how I unapply calibration...
-> no... also the original split does seem to fit. ...let me find the place where it's actually split. Or are sweeps missing...
Let me get a motion-corrected sweep when the car is rotating, e.g. from odo-set 05: 2011_09_30_drive_0018, scan 794 or 1810
-> the seem is at pi... so that would be where it should "fit" with the next sweep. I should try this with 1810 where it is clear where it starts and stops
what seems to me to be the case is that the scans are split by device-rotation at some perhaps arbitrary orientation, and then saved as "point-clouds" starting from point heading 0. -> Yas, confirmed on 1810 at -pi/2 (because of my atan screwup)
But something is strange. The points where it wraps (at -pi/2) are not on the edges of the motion corrected one.
Is the motion correction not taking the position of the point into account... or are it actually different points (nope, reflectivity is the same)
If not taken into account then there should be errors at the edges of the sweep. ...how to see those...

 plot "odo_05_001810.txt" using (atan2($2,$1)):(atan($3/sqrt($1**2+$2**2)))
 replot "odo_05_001810.txt" using (-3<atan2($2,$1)?(atan2($2,$1)<3?1/0:atan2($2,$1)):atan2($2,$1)):(atan($3/sqrt($1**2+$2**2))):($0) with labels

 plot "raw_05_001813_unap.txt" using 2:1
 replot "raw_05_001813_unap.txt" using ($0==108312?$2:1/0):1:0 with labels lc "blue"
 replot "raw_05_001813_unap.txt" using ($0==106327?$2:1/0):1:0 with labels lc "blue"
 replot "raw_05_001813_unap.txt" using ($0==102337?$2:1/0):1:0 with labels lc "blue"
 replot "raw_05_001813_unap.txt" using ($0==100294?$2:1/0):1:0 with labels lc "blue"
 replot "raw_05_001813_unap.txt" using ($0==98219?$2:1/0):1:0 with labels lc "blue"
 replot "raw_05_001813_unap.txt" using ($0==96153?$2:1/0):1:0 with labels lc "blue"
 replot "raw_05_001813_unap.txt" using ($0==94099?$2:1/0):1:0 with labels lc "blue"

Assuming now that laser positions were not taken into account during motion correction. Especially behind the car this can result in big errors because points measured at the start of the sweep are ended to the end and vice versa.

Fix the rotational position angle, such that it is in line with the horizontal point angle -> fixed
Use the correct begin and end of sweep ; check with consecutive sweep -> fixed (made a script for it)
adjusted unapply_motion_sweep script and works for the straight ahead sweep, though not perfect
try out other sweeps -> a bit more problems when there's rotation
hmmm in 1810 of 2011_09_30_drive_0018 there's a rare occurrence of one of the laser firing an extra time, while the others don't at .1 degrees
compare raw_unap data -> looks okayish but not perfect
read poses, pose-times and velodyne-times from the odometry dataset -> seems poses are in camera frame or something... have to undo those calibrations -> calibrations are given in the odometry dataset (in yet a different form : - ), precisly described in the devkit/readme.txt of the odometry dataset
comparing odo-poses with oxts for set 05. 3 scans difference. velodyne timestamp.txt is in the middle I assume, like odo pose. So 11:54:39.232045294, which is just after oxts 45 -> hmmm 65 is a much better fit (not perfect though), wonder if I'm doing something wrong
-> Oh me.... just realized that the odometry test sets of course do not have poses. Sigh... Let's first try to see if it is actually sensible to put energy in doing the odometry stuff, by incalibrating the training sets based on the raw data.
...discretize -> pretty simple with the uncalibrated raw data -> images look good
create files with pixel location per point -> script ready
check where each dataset starts -> check, updated table. for 07 the zip is broken... should download again
fix N exceptions (in the 04 set)
V- shift seems not to be applied (04/0004)
V- single laser fired (04/0005) -> hmmm, but it is annotated.... let's keep it in for now -> aha, fixed this too, it was caused by using the wrong laser
V- missing image (04/0027)
Hmmm, there's inconsistencies in the semantic labeling, set 04, frame 219,220, pole turns into trunk
make script that unzips -> uncalibrates -> discretizes -> throws unzipped away
fix M exceptions
V- data set 00 rainbox luxaflex -> didn't load semantic data from disc, added check
V- data set 01 missing frames 257-428 -> it's just a stupid threshold I used to pick the next laser. fixed it.
V- still missing images...something wrong with 10 0858, and later with 01, eg 0480. -> I should create a more proper fix for this -> trying way to differentiate lasers (works for 01. ... and for the rest)
put the data somewhere... (probably zipped 5gb) 21290 sweeps * 500K (172K) binary (zipped) = 3.7 GB (10.6) -> mist -> nice
fix borders by using points from consecutive sweeps
compare different projections, e.g. set 00, frame 660 (cyclist from oposite direction); set 01, frame 429 (passing car)

Focussing now on getting undoing the motion correction.
Check how much measurements can still be unambigiously matched to rays (can also verify using raw data) -> should just plot it on top of each other -> seems about .1 rad when using absolute angle
just one gradient descent step *should* be enough... -> hmmm, seeing the gradient descent steps, perhaps lm would be a better fit..
V-check if vertical error has outliers -> yes, there's an outlier (most have < 1e-4, some 1e3, outlier 1e2
V-compare errors with raw sweep -> clearly shows lack of convergence (although with lm better)
V-implement lm -> works quite nicely... probably overfitting...
V-check if error is low when using oxts based pose -> 00_odo .05rad should have pose 0.0101147 -7.00172e-06  4.35662e-05  9.10794e-06  1.32077e-05  1.83678e-06 (i.e. moving forward a cm, no rotation. hmmm 1m /scan, 10m/s, 36km/h (not that fast...)) -> it is low, but not the lowest.
V-should try moving pose, or perhaps even liespline... -> yes I think that is key
V-should somehow contraint non-vehicle motion -> perhaps not necessary
V-loop to get more points in if max error is under some limit
V-remove points in the looping
V-output points before removing to check
V-speed ups
V--sample X points -> (perhaps not needed when removing points... (%10, 6x faster)
--vehicle motion assumption
V--less manifold (1.5x faster)
V-should start checking vertical angle more properly... also plotting it for 0000000003_unap
V-to check vertical error bit better -> does not really help...
X-stop using the Triess solution of finding the laser id -> perhaps not that important

Vhmmm, I should do a more local search for the pose (well... change of pose),
Vperhaps the pose used has a large "knick" (as in, linear interpolation) which should be modelled -> not apparent in oxts
Vcompare computed poses with the ones based on oxts
Vhmmm, i should compute the heading in lidar frame, and not in cloud frame for the interpolation
Xtry three-step heading computation -> not, no real difference (empirically, should do the math...)
  plot "relative_poses" using 8:1 with lines, "relative_poses" using 8:2 with lines,"relative_poses" using 8:3 with lines,"relative_poses" using 8:4 with lines,"relative_poses" using 8:5 with lines,"relative_poses" using 8:6 with lines
  replot "00_odo_unmo.txt" using 12:6, "00_odo_unmo.txt" using 12:7,"00_odo_unmo.txt" using 12:8,"00_odo_unmo.txt" using 12:9,"00_odo_unmo.txt" using 12:10,"00_odo_unmo.txt" using 12:11
  replot "00_odo_unmo.txt" using 12:6 with lines, "00_odo_unmo.txt" using 12:7 with lines,"00_odo_unmo.txt" using 12:8 with lines,"00_odo_unmo.txt" using 12:9 with lines,"00_odo_unmo.txt" using 12:10 with lines,"00_odo_unmo.txt" using 12:11 with lines
hmmm, perhaps I should check the first, the last, and save the middle (after checking)
it's still pretty shaky. just gradient descent does not work
Vwhy is there so much jitter per point?... I think just numerical instability with logse3-ing etc

VLet me investigate the applied poses more properly by estimating based on raw and corrected data
V-> wow, for 2011_09_30_drive_0016_extract 0000000003.txt, just a single pose gives exact estimates: error < 5e-5 (in x-y plane, in z it is a <2e-4
   this is due to the corrected point cloud precision which is 1e-4
   this probably also means that the motion correction was applied on the 1e-3 precise raw data
   and perhaps also that it was done with a single pose (perhaps averaging pitch roll heading, and not se3's)
V- check uncalib -> checked

For estimating, let me try to use a more global error function based on neighboring points with approx the same distance measure
V-define the error
V-> looking at plots of gaps in raw data, it doesn't look that consistent... uniform noise between 0.0030 and 0.00327 radians. still error is vissible, but perhaps not in all scenes (e.g. driving slower).
V-> a well, it is uniform, so the more points you use, the more signal you get
V-> check neighbors being used
V-> should compute the correspondences up front

Still not working smoothly... perhaps I should just use the gaps pattern -> determine pattern. Try to match snippets. Use matches to estimate. 

-> check out other scenes
  #paste uncalibrated odo scans and raw scans (should write a one liner)
  plot "tmp/00_odo_un.txt" using 2:($2-$6)
  replot "tmp/00_raw_un.txt" using 2:($2-$6)


V-check error in example
V-...minimize
  -> get's stuck quite quickly with just neighboring points
